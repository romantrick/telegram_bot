# План разработки Telegram-бота для мониторинга пулов DefiLlama

**Цель:** Создать Telegram-бота, который будет получать данные по APR/APY и TVL для заданного списка пулов из API DefiLlama и будет развернут на Railway.

**План Действий:**

1.  **Подготовка конфигурации пулов (`pools_config.json`):**
    *   Преобразовать данные из `apr (1).csv` в JSON формат.
    *   Использовать ID пула из DefiLlama (колонка "ссылка defilama" в CSV) как основной идентификатор (`defilama_id`).
    *   Для пулов без ID в CSV установить `defilama_id` в `null` и использовать комбинацию `chain`, `project`, `symbol` для поиска.
    *   Добавить поле `user_comment` для удобства идентификации пула пользователем.
    *   Пример структуры элемента:
        ```json
        {
          "defilama_id": "aa70268e-4b52-42bf-a116-608b370f9501", // или null
          "chain": "ethereum",
          "project": "aave",
          "symbol": "usdc",
          "user_comment": "aave usdc" // Из CSV (протокол + тикер)
        }
        ```

2.  **Обновление зависимостей (`requirements.txt`):**
    *   **Добавить:**
        *   `python-telegram-bot[httpx]` (для асинхронной работы с Telegram)
        *   `python-dotenv` (для загрузки `.env`)
    *   **Оставить:**
        *   `requests` (для запросов к DefiLlama)
    *   **Удалить:**
        *   `pandas` (не используется ботом)
        *   `web3` (прямые запросы к блокчейну убираются)
    *   Итоговый `requirements.txt`:
        ```
        requests
        python-telegram-bot[httpx]
        python-dotenv
        ```

3.  **Модификация кода бота (`bot.py`):**
    *   **Удалить старый код:**
        *   Функции `get_aave_asset_apy`, `get_curve_crvusd_apy`.
        *   Глобальные переменные и константы, связанные с Aave/Curve (ABI, адреса, RAY, CURVE_APR_DECIMALS).
        *   Импорт `web3`, `json` (если больше не нужен), `decimal` (если не нужен для форматирования).
    *   **Чтение конфигурации:**
        *   Добавить функцию `load_pools_config(path="pools_config.json")`, которая читает и возвращает список словарей из JSON. Обработать возможные ошибки чтения файла.
    *   **Запрос к DefiLlama:**
        *   Создать асинхронную функцию `get_defilama_pools_data()`.
        *   Использовать `requests` (или `httpx`, если `python-telegram-bot` его предоставляет) для GET-запроса к `https://api.llama.fi/pools`.
        *   Обработать возможные ошибки запроса (таймауты, HTTP-ошибки).
        *   Вернуть результат (список словарей пулов DefiLlama).
    *   **Обновить команду (переименовать в `/pools`):**
        *   Изменить регистрацию обработчика: `CommandHandler("pools", pools_command)`.
        *   Создать асинхронную функцию `pools_command(update: Update, context: ContextTypes.DEFAULT_TYPE)`.
        *   Внутри `pools_command`:
            *   Вызвать `load_pools_config()` для получения списка отслеживаемых пулов.
            *   Вызвать `get_defilama_pools_data()` для получения данных от API.
            *   Реализовать логику сопоставления:
                *   Создать словарь данных DefiLlama для быстрого доступа по `id`: `{pool['id']: pool for pool in defilama_data}`.
                *   Итерировать по списку отслеживаемых пулов из конфига.
                *   Если `defilama_id` есть в конфиге, искать пул в словаре DefiLlama по этому ID.
                *   Если `defilama_id` нет, итерировать по всем данным DefiLlama и искать совпадение по `chain`, `project`, `symbol` (сравнение строк без учета регистра и пробелов).
                *   Сохранять найденные данные (APY, TVL) для каждого отслеживаемого пула. Обработать случаи, когда пул не найден.
            *   Выбрать подходящее поле APY (например, `apy` или `apyBase`, возможно, суммировать с `apyReward` если нужно). Уточнить логику выбора APY при необходимости.
            *   Сформировать сообщение:
                *   Заголовок: "Данные по пулам из DefiLlama:"
                *   Для каждого найденного пула: `[Комментарий пользователя]: APY X.XX%, TVL $Y,YYY.YY` (форматировать числа).
                *   Для ненайденных пулов: `[Комментарий пользователя]: Не найден в DefiLlama`.
            *   Отправить сообщение пользователю (`update.message.reply_text`).
    *   **Обновить `/start`:**
        *   Изменить текст приветствия и инструкций, упомянув команду `/pools`.
    *   **Обновить `main()`:**
        *   Убедиться, что используется `Application.builder().token(token).request(request).build()` с увеличенными таймаутами, как было ранее.
        *   Заменить регистрацию обработчика `/apy` на `/pools`.

4.  **Подготовка к деплою на Railway:**
    *   **Dockerfile:**
        *   Убедиться, что базовый образ Python подходит.
        *   Копируются `requirements.txt`, `bot.py`, `pools_config.json`.
        *   Устанавливаются зависимости: `pip install --no-cache-dir -r requirements.txt`.
        *   Задается команда запуска: `CMD ["python", "bot.py"]`.
    *   **Переменные окружения (Railway Secrets):**
        *   `TELEGRAM_BOT_TOKEN`: Токен вашего Telegram-бота.
        *   `RAILWAY_API_TOKEN` (или другое имя): Ваш API-токен Railway (будет запрошен позже, если потребуется для автоматизации деплоя, иначе используется Railway CLI).
    *   **Локальный запуск:** `python bot.py` (требует наличия `.env` с `TELEGRAM_BOT_TOKEN`).
    *   **Деплой через Railway CLI:**
        1.  `railway login`
        2.  `railway link` (связать проект с Railway)
        3.  `railway up` (запустить деплой)
        4.  Настроить переменные окружения в интерфейсе Railway.

**Следующий шаг:** Переключиться в режим `code` для реализации этого плана.